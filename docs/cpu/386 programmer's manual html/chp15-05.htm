<html>
<head>
<title>
15.5  Virtual I/O
</title>
<body>
<a name="15-05"></a>
Prev: <a href="chp15-04.htm">15.4  Additional Sensitive Instructions</a><br>
Next: <a href="chp15-06.htm">15.6  Differences From 8086</a>
<hr>
<h2>
15.5  Virtual I/O
</h2>
<p>
Many 8086 programs that were designed to execute on single-task systems use
I/O devices directly. However, when these same programs are executed in a
multitasking environment, such use of devices can be disruptive. The 80386
provides sufficient flexibility to control I/O in a manner that both suits
the needs of the new environment and is transparent to the 8086 program.
Designers may take any of several possible approaches to controlling I/O:
<ul>
<li> Implement or emulate the 8086 operating system as an 80386 program and
     require the 8086 application to do I/O via software interrupts to the
     operating system, trapping all attempts to do I/O directly.

<li> Let the 8086 program take complete control of all I/O.

<li> Selectively trap and emulate references that a task makes to specific
     I/O ports.

<li> Trap or redirect references to memory-mapped I/O addresses.
</ul>
The method of controlling I/O depends upon whether I/O ports are I/O mapped
or memory mapped.
<p>
<a name="15-05-01"></a>
<h3>15.5.1  I/O-Mapped I/O</h3>
<p>
I/O-mapped I/O in V86 mode differs from protected mode only in that the
protection mechanism does not consult IOPL when executing the I/O
instructions IN, INS, OUT, OUTS. Only the I/O permission bit map controls
the right for V86 tasks to execute these I/O instructions.
<p>
The I/O permission map traps I/O instructions selectively depending on the
I/O addresses to which they refer. The I/O permission bit map of each V86
task determines which I/O addresses are trapped for that task. Because each
task may have a different I/O permission bit map, the addresses trapped for
one task may be different from those trapped for others. Refer to Chapter 8
for more information about the I/O permission map.
<p>
<a name="15-05-02"></a>
<h3>15.5.2  Memory-Mapped I/O</h3>
<p>
In hardware designs that utilize memory-mapped I/O, the paging facilities
of the 80386 can be used to trap or redirect I/O operations. Each task that
executes memory-mapped I/O must have a page (or pages) for the memory-mapped
address space. The V86 monitor may control memory-mapped I/O by any of
these means:
<ul>
<li> Assign the memory-mapped page to appropriate physical addresses.
     Different tasks may have different physical addresses, thereby
     preventing the tasks from interfering with each other.

<li> Cause a trap to the monitor by forcing a page fault on the
     memory-mapped page. Read-only pages trap writes. Not-present pages trap
     both reads and writes.
</ul>
Intervention for every I/O might be excessive for some kinds of I/O
devices. A page fault can still be used in this case to cause intervention
on the first I/O operation. The monitor can then at least make sure that the
task has exclusive access to the device. Then the monitor can change the
page status to present and read/write, allowing subsequent I/O to proceed at
full speed.
<p>
<a name="15-05-03"></a>
<h3>15.5.3  Special I/O Buffers</h3>
<p>
Buffers of intelligent controllers (for example, a bit-mapped graphics
buffer) can also be virtualized via page mapping. The linear space for the
buffer can be mapped to a different physical space for each virtual 8086
task. The V86 monitor can then assume responsibility for spooling the data
or assigning the virtual buffer to the real buffer at appropriate times.
<p>
<hr>
Prev: <a href="chp15-04.htm">15.4  Additional Sensitive Instructions</a><br>
Next: <a href="chp15-06.htm">15.6  Differences From 8086</a>
</body>
</html>
