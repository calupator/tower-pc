<html>
<head>
<title>
16.1  How the 80386 Implements 16-Bit and 32-Bit Features
</title>
<body>
<a name="16-01"></a>
Prev: <a href="chp16-00.htm">Chapter 16  Mixing 16-Bit and 32 Bit Code</a><br>
Next: <a href="chp16-02.htm">16.2  Mixing 32-Bit and 16-Bit Operations</a>
<hr>
<h2>
16.1  How the 80386 Implements 16-Bit and 32-Bit Features
</h2>
<p>
The features of the architecture that permit the 80386 to work equally well
with 32-bit and 16-bit address and operand sizes include:
<ul>
<li> The D-bit (default bit) of code-segment descriptors, which determines
     the default choice of operand-size and address-size for the
     instructions of a code segment. (In real-address mode and V86 mode,
     which do not use descriptors, the default is 16 bits.) A code segment
     whose D-bit is set is known as a USE32 segment; a code segment whose
     D-bit is zero is a USE16 segment. The D-bit eliminates the need to
     encode the operand size and address size in instructions when all
     instructions use operands and effective addresses of the same size.

<li> Instruction prefixes that explicitly override the default choice of
     operand size and address size (available in protected mode as well as
     in real-address mode and V86 mode).

<li> Separate 32-bit and 16-bit gates for intersegment control transfers
     (including call gates, interrupt gates, and trap gates). The operand
     size for the control transfer is determined by the type of gate, not by
     the D-bit or prefix of the transfer instruction.

<li> Registers that can be used both for 32-bit and 16-bit operands and
     effective-address calculations.

<li> The B-bit (big bit) of data-segment descriptors, which determines the
     size of stack pointer (32-bit ESP or 16-bit SP) used by the CPU for
     implicit stack references.
</ul>
<p>
<hr>
Prev: <a href="chp16-00.htm">Chapter 16  Mixing 16-Bit and 32 Bit Code</a><br>
Next: <a href="chp16-02.htm">16.2  Mixing 32-Bit and 16-Bit Operations</a>
</body>
</html>
