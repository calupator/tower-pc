                   Pixel panning and split screens

                    by Richard Wilton and Serj I.
                    PC Tech Journal november 1988

      Pixel  panning  на уровне hardware позволяет плавно перемещать
  изображение по экрану вверх,  вниз,  влево  и  вправо  так,  чтобы
  пользователь не ждал программной перерисовки изображения.  Обычно,
  большинство программистов выполняет скольжение графики или  текста
  через  экран  путем копирования блока символов или пиксел из одной
  области видеобуфера в другую.  VGA hardware однако может очищать и
  быстро  перемещать  часть  или  все  изображение  и  при  этом нет
  необходимости менять местами пикселы программным путем.

      Panning  экономит  время  при   разработке   и   использовании
  приложений в которых видеовывод выходит за пределы одного экрана и
  составляет большое количество данных.  Например, в  медицинских  и
  научных   приложениях   часто  требуется,  чтобы  экран  постоянно
  перематывался влево для вывода новой информации.

      Split  screen  позволяет  изобразить   две   отдельные   части
  видеобуфера  одновременно  -  одну  вверху,  другую  внизу.  Когда
  используется split screen, команды  и  данные,  выводимые  в  одну
  часть,  могут  автоматически  помещать информацию в другую.  Таким
  образом, пользователь может вводить изменения в одну часть  экрана
  и видеть как это отразится на другой части тогоже экрана.

      На  практике эти особенности однако используются нечасто из-за
  отсутствия  для  VGA  hardware   поддержки   со   стороны   языков
  программирования  и  их  библиотек.  По мере того как разработчики
  будут больше знать о программировании VGA  эта  ситуация  вероятно
  будет меняться.

      VGA ROM BIOS не имеет программной поддержки ни для panning, ни
  для  split-screen,  но  поддерживает,  вместо  этого,  перемещение
  экранного  окна  в  видеобуфере.   Например,  функция  5  INT  10H
  изменяет  значение  в  start  address  регистрах  CRT  контроллера
  (CRTC),  позволяя использовать более одного полного текстового или
  графического экрана.  В документации IBM на ROM BIOS каждый полный
  экран  данных определен как дисплейная страница.  Такая страничная
  организация не является помощью для panning режима,  но  позволяет
  разработчикам    размещать    изображаемые    данные    в   других
  неиспользуемых частях видеобуфера.

      Несмотря на отсутствие  поддержки  со  стороны  ROM  BIOS,  вы
  можете  разрабатывать  приложения с использованием pixel-panning и
  split-screen  на  уровне  hardware,  и  это  без  большого  об'ема
  программирования.    Процедуры,   представленные  в  этой  статье,
  демонстрируют  как   менять   размеры   видеобуфера,   содержащего
  текстовые  или графические изображения необычной ширины или длины,
  и затем плавно перемещать (pan) экранное  окно  через  все  данные
  видеобуфера.  Они также демонстрируют работу со split экраном.

                 YELLOW FOR CAUTION (предупреждение)

      Хотя  технические  приемы panning и split сравнительно просты,
  они демонстрируют некоторые трудности в программном  использовании
  видео  hardware.   Любая  программа,  использующая эти особенности
  VGA, непереносима на видео hardware, которая не поддерживает их.

      Во  многих  разрабатываемых  программах  не  используются  эти
  особенности  из-за  того,  что  они  не поддерживаются CGA - более
  ранним графическим стандартом IBM для PC.  Однако  это  наименьшая
  из неприятностей, так как VGA сейчас является стандартом для новых
  компьютерных систем, а  CGA  перестает  использоваться.   Очевидно
  больше   неприятностей   доставляет   тот   факт,   что  некоторые
  технические приемы, используемые для VGA, не полностью работают на
  EGA,  который  был  введен  IBM  после  CGA  и перед VGA.  В обоих
  CRTC-контроллерах EGA отсутствуют некоторые функции,  имеющиеся  в
  VGA.  Кроме того, использование указанных особенностей требует для
  EGA больше кодов.

      Другой потенциальной прблемой являются некоторые неудачные VGA
  не фирмы IBM.  Все описываемые в этой статье особенности относятся
  к VGA IBM.  Представленные примеры  могут  быть  использованы  как
  дополнительная   мера   предосторожности   :    покупатели   могут
  попробовать их в качестве тестов перед покупкой машины.

      Использование  VGA  не   является   непреодолимой   проблемой.
  Изучение  как можно большего числа возможностей VGA для текстового
  и  графического  видео-режимов  есть  ключ   к   совершенствованию
  пакетов,  требующих быстрого появления на экране текста и графики.


                            THE TRUE GRIT

      Тогда как software работает медленно и прерывисто, hardware  -
  быстро   и   плавно.   Манипулируя  несколькими  параметрами  VGA,
  разработчик может плавно перемещать изображение через весь  экран.
  VGA hardware позволяет также разделять изображение на две картинки
  по горизонтали, причем одна из них может плавно перемещаться в  то
  время как другая остается неподвижной.

      Для   понимания   того,  как  VGA  hardware  поддерживает  оба
  указанных режима, рассмотрим, что  общего  между  изображением  на
  экране  и данными, размещенными в видеобуфере VGA.  Буфер, который
  содержит все данные, выведенные на экран, достаточно  большой  для
  того,  чтобы  хранить гораздо больше информации, чем требуется для
  одного полностью заполненного экрана.  Это важно, что  изображение
  на  экране  может  быть  только  частью изображения, хранящегося в
  видеобуфере.

      Изображение на экране  есть  окно  на  содержимом  видеобуфера
  (Рис.   1).   Не  следует  путать  это с понятием окна в Microsoft
  Windows, где окно представляет собой логическую область в  которую
  программа выводит данные.  Вместо этого экранное окно ограничивает
  видимую часть всех данных, содержащихся в видеобуфере.

      Хотя  видеобуфер   адресуется   линейной   последовательностью
  адресов,  представляйте  его  как  двумерный, в котором логическая
  ширина - это число символов или писел которое может быть выведенно
  на   экранную  строку.   Ключом  к  пониманию  того  как  работают
  split-screen и panning является то, что экранное окно  может  быть
  спозиционированно  на  любую  часть  видеобуфера,  или  (в  случае
  split-screen) на две отдельные части данных в буфере.

      Однако,  фактически  все  программы  для  VGA  не   используют
  дополнительную  память  в  видеобуфере.  В них предполагается, что
  начало экранного  окна  совпадает  с  началом  видеобуфера  и  что
  логическая  ширина  видеобуфера  такая  же  как  логическая ширина
  экрана.  В действительности видеобуфер VGA длиннее чем изображение
  на  экране.   Чтобы использовать дополнительную RAM в видеобуфере,
  разработчики должны знать как программировать контроллеры VGA, для
  изменения   начала   окна   и   логической   ширины   видеобуфера.
  Большинство  программистов  выполняют  это,   составляя   короткие
  ассемблерные  процедуры,  которые обращаются непосредственно к VGA
  hardware, но некоторые операции могут быть выполнены  через  вызов
  VGA  ROM  BIOS.   Оба  эти  приема используются в листингах 1 - 8,
  приводимых ниже.

                            NEW BEGINNINGS

      Экранное  окно  перемещается  путем  изменения  его  начала  в
  видеобуфере.    Чтобы  выполнить  это  вам  необходимо  знать  как
  программируются  CRTC,  являющиеся  частью  схемы   VGA,   которая
  синхронизирует  дисплейные схемы, связывая видеобуфер с временными
  сигналами,  управляющими  движением   электронного   пучка   через
  видеодисплей.

      В  действительности,  CRTC перемещают экранное окно, определяя
  адрес в видеобуфере, который является началом (т.е.  левым верхним
  углом)   экрана.    CRTC   также   определяют   логическую  ширину
  видеобуфера.  Комбинация этих параметров  определяет  какая  часть
  видеобуфера изображена на экране.

      Для  управления  временными сигналами, необходимыми для работы
  видеодисплея, CRTC VGA используют установку 25 8-битовых регистров
  для  размещения широкого диапазона значений.  Среди этих регистров
  три :  start address high, start  address  low,  offset  указывают
  начальный  адрес экранного окна и ширину видеобуфера.  Разработчик
  может менять эти параметры, устанавливая значения  соответствующих
  CRTC регистров.

      Все   регистры  CRTC  VGA  доступны  для  использования  через
  8-битовый  I/O  порт  3D5H.   При  использовании  порта,   сначала
  запишите  в порт 3D4H номер регистра (от 0 до 18), затем читайте и
  записывайте через порт 3D5H, обмениваясь информацией  с  регистром
  CRTC.   (В  видеорежимах  7  и  0FH,  которые эмулируют режим EGA,
  поддерживаемый  монохромным  дисплеем  IBM  5151,  соответствующие
  адреса портов :  3B4H и 3B5H).

      Процедура,  представленная  в  листинге  1, считывает значение
  регистра CRTC, представленная в листинге 2, записывает значение  в
  регистр.   Здесь  представлены ассемблерные листинги, но, в общем,
  разработчики могут пользоваться языками высокого  уровня,  которые
  поддерживают  I/O порт.  Например, обе функции Microsoft C :  outp
  и inp и функции BASIC :  INP и OUT  могут  осуществлять  доступ  к
  регистрам CRTC.

      Вертикальное   позиционирование.    Несколько  регистров  CRTC
  управляют позицией начала экранного окна.  Для этого  используются
  два  start  address  регистра,  имеющие номера 0CH и 0DH.  Эти два
  регистра  содержат  16-битовое  смещение  первого  байта   данных,
  выводимых  на дисплей, в видеобуфере, причем старший байт смещения
  в регистре 0CH и младший байт в регистре 0DH.  когда вы  вызываете
  VGA  ROM  BIOS для установки видеорежима, смещение в start address
  регистрах устанавливается равным нулю, позиционируя экранное  окно
  на начало видеобуфера VGA.

      Изменение   значения   start   address   вызывает  перемещение
  экранного окна в видеобуфере.  Как это выполняется в программе  на
  "C"   показано   в   листинге   3,   где  значение  start  address
  увеличивается  на  80  в  программном  цикле  каждый  раз,   когда
  нажимается  клавиша.  В случае текстового режима по 80 символов на
  строку экранное окно перемещается каждый раз  на  строку  символов
  вниз.

      В  графическом  режиме  результаты аналогичны.  Отличие в том,
  что каждая строка видеобуфера  состоит  из  одних  пиксел,  вместо
  символов.   В  результате  вертикальное перемещение экранного окна
  более плавное чем в случае текстовых режимов.

      Как   сделать   попиксельную    вертикальную    перемотку    в
  буквенно-цифровых  режимах  ?   Чтобы  сделать  это вам необходимо
  поместить экранное окно не только на выделенную  строку  символов,
  но  также на выделенную scan-линию в пределах самой верхней строки
  символов.   CRTC  VGA  дает   способ   сделать   это   через   его
  preset-row-scan  регистр  (8).   Значения  пяти  младших бит этого
  регистра устанавливаются в ноль каждый раз  когда  вызывается  ROM
  BIOS  для  установки  видеорежима;   при  изменении  этих значений
  меняется scan-линия с которой изображается первая строка символов.
  Таким образом, комбинация значений start address и preset-row-scan
  помещает начало экрана на выделенную пиксельную координату Y.

      Например, в VGA определен буквенно-цифровой  режим  80х25,  16
  цветов;  каждая символьная строка содержит 16 scan-линий (т.е.  16
  пиксел).  Чтобы  выполнить  плавную  перемотку,  надо  увеличивать
  значение  preset-row-scan  от  0  до  15.   Взять следующую строку
  символов, увеличить апраt address регистр  и  установить  значение
  preset-row-scan в 0.

      Горизонтальное  позиционирование.   Когда  эксперементируете с
  CRTC start address регистрами,  обратите  внимание,что  постепенно
  увеличивая  значение  этих регистров, вы перемещаете начало экрана
  вправо, символ за символом.  Как и в вертикальном позиционировании
  вы  должны программировать увеличение регистра так, чтобы получить
  попиксельное горизонтальное позиционирование экранного окна.

      Попиксельным   горизонтальным   позиционированием    управляет
  attribute  controller  VGA.   Подобно  CRTC,  attribute controller
  использует установку 8-битовых регистров,  скомпанованных  в  одну
  пару  I/O  портов,  для управления изображением данных.  Attribute
  controller    вызывает,    однако,    больше    затруднений    при
  программировании  чем CRTC потому, что hardware VGA использует I/O
  порт 3C0H и для определения номера регистра, и для записи данных в
  регистр.   (Эти функции I/O портов управляются переключателем, чье
  положение переустанавливается когда программа читает  значение  из
  VGA  input-status  регистра  3BAH  или 3DAH).  Чтобы избежать этих
  сложностей, воспользуйтесь ROM BIOS INT 10H функция  10H,  которая
  предоставляет две подфункции (7 и 0) которые читают и записывают в
  любой определенный attribute controller регистр.

      Вы должны программировать и CRTC, и attribute  controller  для
  того,  чтобы  установить  начало  экрана  на определенный пиксел в
  горизонтальном      направлении.       Attribute      controller's
  horizontal-pel-panning регистр (13H) определяет начальный пиксел в
  байте  видеобуфера,определенном  start  address  регистрами  CRTC.
  Ассемблерная  проограмма,  представленная в листинге 4, использует
  эти start address регистры для позиционирования экранного окна  на
  указанное место пиксела в видеобуфере.

      Определяющее   значение  для  horizontal-pel-panning  регистра
  может несколько изменяться из-за того, что  VGA  может  изображать
  либо  8, либо 9 пиксел на каждый байт в видеобуфере, в зависимости
  от  установленного  видеорежима.   Вы  можете   определить   число
  выводимых  пиксел  на  байт,  проверяя  младший  бит clocking-mode
  регистра (1) в VGA sequencer.  Регистр  проверяется  путем  записи
  его  номера  (1)  в  I/O  порт  3C4H  и, затем, чтения порта 3C5H,
  который возвращает содержимое регистра.   Вы  можете  использовать
  информацию    в    таблице    1,    чтобы    определить   значение
  horizontal-pel-panning,  необходимое   для   создания   требуемого
  смещения изображения.

      Все  эти технические приемы программирования hardware, которые
  позиционируют начало экранных окон на указанное положение пиксела,
  показаны  вместе в листинге 4.  Они оформлены в виде вызываемых из
  "C" процедур.   Разработчик  может  выполнить  плавный  panning  и
  перемотку,  вызывая  процедуры из повторяющегося цикла.  Например,
  C-программа, представленная в листинге 5, использует  подпрограмму
  из листинга 4 для плавной перемотки экранного окна вниз и вверх на
  100 пиксел.

      Преобразование этой программы в программу  для  горизонтальной
  перемотки   экранного   окна,  вместо  вертикальной,  представляет
  проблему.  Логическая ширина видеобуфера такая же как у  экранного
  окна,    поэтому   горизонтальный   panning   просто   оборачивает
  изображение   вокруг   экрана.    Увеличение   логической   ширины
  видеобуфера   позволит  разработчику  сканировать  любой  материал
  который простирается сверх ширины экрана.

            RESHAPING THE BUFFER (shape - придавать форму)

      Ключом  к  изменению  размеров  видеобуфера  является   offset
  регистр  CRTC  (13H).   Этот  регистр определяет логическую ширину
  видеобуфера,  измеряемую  в  16-битовых  словах  (не  байтах).   В
  80-столбцовых  буквенно-цифровых  видеорежимах  логическая  ширина
  линии составляет 80 байт и значение offset регистра равно 28H  (40
  decimal).   В графических режимах каждый байт имеет 8 изображаемых
  пиксел.  Таким образом, в режимах с горизонтальным разрешением 640
  пиксел offset регистр имеет значение тоже равное 28H.

      Чтобы  изменить  логическую  ширину  видеобуфера,  надо просто
  установить offset регистр CRTC.  Например, вы можете  увеличить  в
  двое  логическую ширину в 80-столбцовых буквенно-цифровых режимах,
  записывая 50H (80 decimal) в offset регистр.  Изменяя  листинг  5,
  можно   сделать   это   перед   panning,  что  позволит  выполнять
  горизонтальный panning 160-символьных строк без заворачивания.

      Когда изменяются рамеры  видеобуфера,  надо  быть  аккуратным,
  чтобы не превысить 64 Kb.  Например, в графическом режиме 640х480,
  логическая ширина видеобуфера должна быть не более  чем  65536  на
  480  линий,  что  составляет  около  136  байт  на линию.  Большие
  значения вызовут заворачивание изображения  вокруг  экрана  сверху
  вниз.

      Чтобы  использовать  экран  дисплея  как  окно  в видеобуфере,
  который содержит более чем один полный  экран  данных,  вы  должны
  заполнить   полностью  видеобуфер  VGA  изображаемым  текстом  или
  графическими данными.  Хотя только часть  содержимого  видеобуфера
  может быть изображена одновременно, вы можете устроить так, что по
  команде  с  клавиатуры  экран  будет  перетекать  (pan)  в   любое
  требуемое место в видеобуфере.

      Процедуры   ROM   BIOS  являются  сравнительно  "терпимыми"  к
  текстовым или графическим  данным,  размещенным  в  неизображаемой
  части  видеобуфера.  Если вы используете подпрограммы VGA ROM BIOS
  для этих целей,  непременно  установите  значение  соответствующих
  переменных  в  сегменте  данных  ROM  BIOS  (см.   табл.  2).  Это
  обеспечит правильную работу функций ROM BIOS INT  10H  для  вывода
  символов (функции 9,0AH,0EH) и вывода пиксел (функция 0CH).

                          SEPARATE BUT EQUAL

      VGA  split-screen  дисплей  есть  в  сущности  дисплей с двумя
  различными  областями  видеобуфера  одновременно.   Верхняя  часть
  видеодисплея,  как показано на рисунке 2, содержит данные из части
  видеобуфера, определенной start address регистрами CRTC, а  нижняя
  часть   видеодисплея   содержит   данные   из  начала  видеобуфера
  (начальное смещение 0 в буфере).

      при использовании split-screen VGA, запомните, что большинство
  коммерческих  программных  пакетов  используют  для  вывода начало
  видеобуфера.  Это область которая появляется в нижней части  split
  экрана.   Например,  когда  используется командный процессор DOS -
  COMMAND.COM, командная линия подсказки будет появляться  в  нижней
  части  зкрана.  Для появления данных в верхней части split экрана,
  вы должны помещать их в область видеобуфера ,которая начинается  с
  адреса, указанного в start address регистрах CRTC.

      Вы  можете  изменить размер обоих частей split-screen дисплея,
  указывая линию сканирования по которой проходит разделение  экрана
  в  line-compare  регистре  (18H)  CRTC.   Подобно другим регистрам
  CRTC, line-compare является 8-битовым регистром  который  содержит
  значение   не  более  FFH  (255  decimal).   Поскольку  VGA  может
  изображать более чем 256 линий сканирования, у  конструкторов  VGA
  hardware   была   возможность  предоставить  разработчикам  способ
  задавать значение line-compare более  255.   Они  добились  этого,
  используя 10-битовое значение line-compare, биты 0-7 расположены в
  line-compare регистре, бит 8  расположен  как  бит  4  в  overflow
  регистре  CRTC (7), бит 9 расположен как бит 6 в maximum-scan-line
  регистре  CRTC  (9).   Таким  образом,  для  того,  чтобы  создать
  split-screen  VGA,  вы  должны  установить значение трех регистров
  CRTC, задавая значение 10-битового line-compare (см.  листинг  6).

      Чтобы  линия раздела скользила вверх и вниз (увеличение одного
  или другого окна),  надо  изменять  значение  line-compare  внутри
  повторяющегося  цикла.   Увеличение  значения  увеличивает размеры
  верхней части изображения, уменьшение - нижней.  Чтобы  отказаться
  от  использования  split экрана, надо задать максимально возможное
  значение  line-compare  (3FFH).   Это  значение  используется  при
  определении всех видеорежимов ROM BIOS.

                          TWO-TONE PROGRAMS

      Многие  разработчики  комбинируют технические приемы panning и
  split-screen в одной и тойже  программе.   Когда  оба  технических
  приема  используются  одновременно в одной программе, нижняя часть
  изображения  в  результате  остается  неподвижной,  когда  верхняя
  перемещается.

      Программа  на  "С",  представленная в листинге 7, дает простой
  пример как получить это.  Программа создает  иллюзию  непрерывного
  вывода,   рисуя   точки  на  правой  стороне  экрана,  "переливая"
  (panning) справо на лево и затем  очищая  все  нарисованные  перед
  этим  точки,  как  только  они  достигнут  левой  стороны  экрана.
  Ассемблерная программа в листинге  8  используется  для  установки
  пиксел на экране.

      Потенциальная  проблема  со  split-screen  panning может иметь
  место  потому,  что  изменение   значения   horizontal-pel-panning
  регистра  перемещает  обе половинки экрана, тогда как разработчики
  могут захотеть переливать только одну часть.   Разработчики  могут
  избежать  этого  двойного panning, устанавливая бит 5 mode-control
  регистра  (10H)  attribute  controller  в   1,   которая   сообщит
  horizontal-pel-panning  регистру attribute controller использовать
  значение, равное нулю, для нижней части split-screen  изображения,
  не  обращая  внимания  на  действительное  значение.  В листинге 6
  функция INT 10H используется для установки бита 5  в  mode-control
  регистре,  чтобы  все  последующие горизонтальные panning операции
  выполнялись плавно.

      Hardware  решение,  однако,  представляет  новую  проблему   -
  заворачивание.     В    некоторых,    определенных    ROM    BIOS,
  буквенно-цифровых режимах, VGA  изображает  девять  горизонтальных
  пиксел  на символ.  В этом случае установка horizontal-pel-panning
  регистра в ноль перемещает изображение на один пиксел  влево,  как
  описано   в   таблице   1.    Если   верхняя  часть  split  экрана
  переливается,  когда  используется  буквенно-цифровой  режим  VGA,
  первый   пиксельный   столбец   в   нижней   части   split  экрана
  заворачивается из левой на правую сторону  экрана.   Использование
  вместо  первого символа пробела в каждой линии нижней части экрана
  гарантирует, что информация не будет заворачиваться.

      Существовавшая в прошлом программная реализация  таких  полных
  преимуществ  особенностей,  как pixel panning и split-screen, была
  ненадежной и медленной.  Но VGA  дает  прекрасную  поддержку  этих
  режимов  на  уровне  hardware,  это  нужно осознать и пользоваться
  этим.

