<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
</HEAD>
<body background="../images/piedra.jpg" bgcolor="#C0C0C0" text="#FFFF66"
link="#CC9900" vlink="#996600" alink="#993300">
<!-- following code added by server. PLEASE REMOVE -->
<!-- preceding code added by server. PLEASE REMOVE -->
<PRE>
&#9;&#9;  Wout Mertens' Guide To Keyboard Programming v1.1
&#9;&#9;  ________________________________________________
&#9;&#9;&#9;&#9;&#9;&#9;&#9; 23 may 94
    Table of Contents
    _________________
    0&#9;Legal Info
    0.1 Preface
    1&#9;Overall Information
    1.1 Extended ASCII
    1.2 Special Functions
    2&#9;DOS Interfacing
    2.1 Functions
    3&#9;BIOS Interfacing
    3.1 Functions
    3.2 Keyboard Flags
    3.3 Keyboard Buffer
    4&#9;Low-Level Interfacing
    4.1 Interfacing And Configuring
    4.2 Lay-Out
    4.3 Scancodes
    4.4 Int 9
    5&#9;Tech Stuff
    A&#9;Acknowledgments
    B&#9;How To Contact Me
    C&#9;The Answer To Life, The Universe And All The Rest
    D&#9;History
    0. Legal Info
    _____________
    This "Keyboard Guide" is (C) Copyright 1994 Wout Mertens.
    All rights reserved.
    THIS DOCUMENT AND  THE ACCOMPANYING SOURCE&#9;CODE FILES ARE&#9;PROVIDED "AS
    IS" WITHOUT  WARRANTY OF  ANY KIND,  EXPRESS OR  IMPLIED, INCLUDING  ANY
    WARRANTY OF MERCHANTABILITY OR FITNESS  FOR A PARTICULAR PURPOSE.&#9;WOUT
    MERTENS WILL NOT BE  HELD LIABLE FOR ANY  DAMAGES OR LOSSES OF  ANY KIND
    THAT  RESULT  FROM&#9;THE  USE  OR  THE  INABILITY  TO USE THE INFORMATION
    PROVIDED IN THIS DOCUMENT OR  THIS SOURCE CODE FILE, INCLUDING,  BUT NOT
    LIMITED TO, LOSS OF PROPERTY OR INCOME.
    This document and its accompanying&#9;source code files are freeware,  not
    public domain.  They  may  be distributed  freely provided&#9;that neither
    file is  modified, and  that they  are distributed&#9;together along&#9;with
    FILE_ID.DIZ in  their entirety,  including the  legal notice,  and that:
    If they are distributed by a third party vendor, no more than $5 U.S. is
    charged for the disk on which the archive, containing this document  and
    the accompanying  source code  files, is stored, except when distributed
    on CD-ROM.
    This legal information supersedes all previous notices.
    0.1. Preface
    ____________
    I wrote this document because I needed info, and thought I could get it
    this way. Boy was I wrong! I ended up finding it all by myself. Anyway,
    I hope you can use it.  It is meant for people who know what interrupts
    are and that 0ah equals 10. Enjoy.
    Oh, almost forgot.&#9;I didn't give this text any page formatting  (aside
    from spaces before and room after for ease of reading) because:
&#9;- I read ALL my documents on-line
&#9;- People have differing page sizes and then it would look like
&#9;  shit for some people and too short for others.
    If you want to print this, well, go ahead and format it, BUT DON'T EVEN
    *THINK* OF SPREADING IT !!! (Except when you ask my permission)
    Everytime  you  see  something  like  d9h  or  65h,  it is a hexadecimal
    number. No trailing 0 was added for ease of typing.
    1. Overall Information
    ______________________
    On the IBM,  there are three  ways, all alike,  to access the  keyboard.
    Via the operating  system, via BIOS  or via low-level  access. Which way
    you use depends very much on  the application you are writing. Games  do
    not use DOS functions, for example. And a file-compressor is really  not
    interested wether  you are&#9;actually pressing  'Y' or  not. Or how long.
    This is the way it works:
       Hardware  |______________ BIOS ________________|   |____ DOS ___|
&#9;&#9;&#9; _______________
&#9;&#9;&#9;_/Keyboard Data|______
&#9;&#9;&#9;|\_____________/     |
       _______&#9; _______|  __________ | _____|_________   ______________
       |key- |___/int 9||__/keyboard|___/BIOS keyboard|___/DOS keyboard|
       |board| | \_____/   |buffer  | | |functions    |   |functions   |
       \_____/ |&#9;   \________/ | \_____________/   \____________/
&#9;       |&#9;       |      |        |&#9;&#9; |
&#9;       |_______________|______|________|_________________|
&#9;&#9;&#9;&#9;       |
&#9;&#9;&#9;      Possible tap points
    The keyboard triggers  IRQ 1 (Interrupt  Request), also known  as int 9.
    Int 9 then translates the keyboard codes into ASCII, or when  necessary,
    extended ASCII, and places it into the keyboard buffer. Also, the  shift
    and lock states are saved in the BIOS Data Area (seg 40h). The  keyboard
    buffer is then  used by the  BIOS functions to  interface with programs.
    The DOS  functions use  the BIOS  keyboard functions  to interface&#9;with
    programs as  well, but  on a  higher and  more protected  (Ctrl-Brk etc)
    level.
    1.1. Extended ASCII
    ___________________
    Extended ASCII is IBM's way  of letting non-ASCII keys be  recognized by
    programs. The BIOS will first send&#9;0 and then the extended ASCII  code.
    Here is the table:
    _________________________________________________________________·
    |Key Hex Dec|Key&#9;   Hex Dec|Key&#9;     Hex Dec|Key      Hex Dec|
    |___________|_________________|_________________|________________|
    |F1   3B  59|Shift-F1   54&#9;84|Ctrl-F1   5E   94|Alt-F1   68  104|
    |F2   3C  60|Shift-F2   55&#9;85|Ctrl-F2   5F   95|Alt-F2   69  105|
    |F3   3D  61|Shift-F3   56&#9;86|Ctrl-F3   60   96|Alt-F3   6A  106|
    |F4   3E  62|Shift-F4   57&#9;87|Ctrl-F4   61   97|Alt-F4   6B  107|
    |F5   3F  63|Shift-F5   58&#9;88|Ctrl-F5   62   98|Alt-F5   6C  108|
    |F6   40  64|Shift-F6   59&#9;89|Ctrl-F6   63   99|Alt-F6   6D  109|
    |F7   41  65|Shift-F7   5A&#9;90|Ctrl-F7   64  100|Alt-F7   6E  110|
    |F8   42  66|Shift-F8   5B&#9;91|Ctrl-F8   65  101|Alt-F8   6F  111|
    |F9   43  67|Shift-F9   5C&#9;92|Ctrl-F9   66  102|Alt-F9   70  112|
    |F10  44  68|Shift-F10  5D&#9;93|Ctrl-F10  67  103|Alt-F10  71  113|
    |___________|_________________|_________________|________________|
    _________________________________________________________________·
    |Key   Hex Dec|Key&#9; Hex  Dec|Key&#9;   Hex&#9;Dec|Key      Hex  Dec|
    |_____________|______________|_________________|_________________|
    |Alt-A  1E&#9;30|Alt-P  19   25|Alt-3     7A&#9;122|down      50   80|
    |Alt-B  30&#9;48|Alt-Q  10   16|Alt-4     7B&#9;123|left      4B   75|
    |Alt-C  2E&#9;46|Alt-R  13   19|Alt-5     7C&#9;124|right     4D   77|
    |Alt-D  20&#9;32|Alt-S  1F   31|Alt-6     7D&#9;125|up&#9;      48   72|
    |Alt-E  12&#9;18|Alt-T  14   20|Alt-7     7E&#9;126|End       4F   79|
    |Alt-F  21&#9;33|Alt-U  16   22|Alt-8     7F&#9;127|Home      47   71|
    |Alt-G  22&#9;34|Alt-V  2F   47|Alt-9     80&#9;128|PgDn      51   81|
    |Alt-H  23&#9;35|Alt-W  11   17|Alt--     82&#9;130|PgUp      49   73|
    |Alt-I  17&#9;23|Alt-X  2D   45|Alt-=     83&#9;131|&#9;&#9;     |
    |Alt-J  24&#9;36|Alt-Y  15   21|&#9;&#9;   |^left     73  115|
    |Alt-K  25&#9;37|Alt-Z  2C   44|NUL&#9;    03&#9;  3|^right    74  116|
    |Alt-L  26&#9;38|&#9;&#9; |Shift-Tab 0F&#9; 15|^End      75  117|
    |Alt-M  32&#9;50|Alt-0  81  129|Ins&#9;    52&#9; 82|^Home     77  119|
    |Alt-N  31&#9;49|Alt-1  78  120|Del&#9;    53&#9; 83|^PgDn     76  118|
    |Alt-O  18&#9;24|Alt-2  79  121|^PrtSc    72&#9;114|^PgUp     84  132|
    |_____________|______________|_________________|_________________|
&#9;   _________________________________________________
&#9;   | 101-key Keyboard Extensions Supported by BIOS |
    _______|_______________________________________________|_______·
    |Key      Hex  Dec|Key&#9;     Hex Dec|Key&#9;   Hex&#9;Dec|
    |_________________|_____________________|______________________|
    |F11       85  133|Alt-Bksp      0E   14|Alt - K /&#9;    A4&#9;164|
    |F12       86  134|Alt-Enter     1C   28|Alt - K *&#9;    37&#9; 55|
    |Shft-F11  87  135|Alt-Esc&#9;     01    1|Alt - K -&#9;    4A&#9; 74|
    |Shft-F12  88  136|Alt-Tab&#9;     A5  165|Alt - K +&#9;    4E&#9; 78|
    |Ctrl-F11  89  137|Ctrl-Tab      94  148|Alt - K Enter  A6&#9;166|
    |Ctrl-F12  8A  138| &#9;&#9;    |&#9;&#9;&#9;   |
    |Alt-F11   8B  139|Alt-up&#9;     98  152|Ctrl- K /&#9;    95&#9;149|
    |Alt-F12   8C  140|Alt-down      A0  160|Ctrl- K *&#9;    96&#9;150|
    |Alt-[     1A   26|Alt-left      9B  155|Ctrl- K -&#9;    8E&#9;142|
    |Alt-]     1B   27|Alt-right     9D  157|Ctrl- K +&#9;    90&#9;144|
    |Alt-;     27   39| &#9;&#9;    |&#9;&#9;&#9;   |
    |Alt-'     28   40|Alt-Delete    A3  163|Ctrl- K Up [8] 8D&#9;141|
    |Alt-`     29   41|Alt-End&#9;     9F  159|Ctrl- K Cn [5] 8F&#9;143|
    |Alt-\     2B   43|Alt-Home      97  151|Ctrl- K Dw [2] 91&#9;145|
    |Alt-,     33   51|Alt-Insert    A2  162|Ctrl- K Ins[0] 92&#9;146|
    |Alt-.     34   52|Alt-PageUp    99  153|Ctrl- K Del[.] 93&#9;147|
    |Alt-/     35   53|Alt-PageDown  A1  161|&#9;&#9;&#9;   |
    |_________________|_____________________|______________________|
    K indicates a key on the numeric keypad (when not in NumLock mode)
    1.2. Special Functions
    ______________________
    There are a few functions and interrupts invoked by int 9:
    int 5   - Print Screen Handler
    int 15h
    fns 4fh - Check Scancode
&#9;      (See int 9)
&#9;85h - System Request
&#9;      Normally IRET
    int 23h - Ctrl-Break handler
    Feel free to revector any of them.
    2. DOS Interfacing
    __________________
    One of the ways to use the keyboard is to let DOS handle it.
    Pro:
&#9;- The keyboard lay-out is unimportant
&#9;- You can even do strings
&#9;- The user doesn't actually have to type
    Contra:
&#9;- You don't  know if you  are actually accessing  the keyboard (like
&#9;  in "Really format drive C: ? Y/N" :-)
&#9;- The functions are quite slow
    2.1. Functions
    ______________
    DOS provides a set of 7 functions to handle the keyboard:
    01h Keyboard Input
    06h Console I/O
    07h No Echo Unfiltered Input
    08h No Echo Filtered Input
    0Ah Buffered Input
    0Bh Input Status
    0Ch Clear Keyboard Buffer &amp; Input
    They all expect the keyboard to be&#9;file handle 0. If you want to  let a
    program think  you are  typing something,  you can&#9;replace this  handle
    with  a  file  containing  the  keystrokes&#9;it  must  read. This is what
    happens when you  'pipe' something in  DOS. (Don't forget  to change the
    handle back to the old one!)
    This also means you can use:
    3Fh Read bytes from handle
    Fn 01h: Keyboard Input
    ----------------------
    Expects: AH  01h
    Returns: AL  Character fetched from the Standard Input
    Description: Reads&#9;(waits&#9;for)  a  character from  the Standard  Input
&#9;&#9; Device.   Echoes  that  character  to&#9;the  Standard Output
&#9;&#9; Device.  If Ctrl-Break is detected, INT 23h is executed.
    Notes:&#9; Extended ASCII keystrokes  (ie, F1-F12, PgUp,&#9;cursor, etc)
&#9;&#9; will require two  calls to this  function.  The  first call
&#9;&#9; will  return  AL=0.   The  second  will  return AL with the
&#9;&#9; extended ASCII code.
    Fn 06h: Console I/O
    -------------------
    Expects: AH  06h
&#9;     DL  0 to 0FEh  Character to send to the Standard Output
&#9;&#9; 0FFh&#9;    Request for input from the Standard Input
    Returns: ZF  Clear (NZ) if character is ready \ on input requests
&#9;     AL  Character read, if ZF is clear   / (when DL=0FFh)
    Description: If DL&#9;is 0FFh,  this performs  a "no&#9;wait" console input,
&#9;&#9; returning  the  Zero  Flag  (ZF)  set&#9;(ZR)  if there is no
&#9;&#9; character  ready.   If  a  character  is  ready, returns ZF
&#9;&#9; cleared (NZ) with the character that was read in AL.
&#9;&#9; If DL&#9;is anything  but 0FFh,&#9;DL is  sent to&#9;the Standard
&#9;&#9; Output.
    Notes:&#9; Does not  check for  Ctrl-Break.   Call twice&#9;for Extended
&#9;&#9; ASCII.
    Fn 07h: No Echo Unfiltered Console Input
    ----------------------------------------
    Expects: AH  07h
    Returns: AL  Character fetched from the Standard Input
    Description: Reads&#9;(waits&#9;for)  a  character  from  the Standard Input
&#9;&#9; Device, returning that character in AL.
&#9;&#9; Unfiltered: Does not detect Ctrl-Break, backspace, etc.
    Notes:&#9; Call twice for Extended ASCII character input.
&#9;&#9; Use Fn 0Bh to check status  (if you don't want to wait  for
&#9;&#9; a key).
    Fn 08h: No Echo Console Input
    -----------------------------
    Expects: AH  08h
    Returns: AL  Character fetched from the Standard Input
    Description: Reads&#9;(waits&#9;for)  a  character  from  the Standard Input
&#9;&#9; Device, returning that character in AL.
&#9;&#9; If Ctrl-Break is detected, INT 23h is executed.
    Notes:&#9; Call twice for Extended ASCII character input.
    Fn 0Ah: Buffered String Input
    -----------------------------
    Expects: AH  0Ah
&#9;     DS:DX Address of an input buffer (see below)
    Returns:&#9; Buffer contains input terminated with CR (ASCII 13h)
    Description: On entry, the buffer at DS:DX must be set up as:
&#9;&#9; __________________________ _ _
&#9;&#9; |max| ? | ?   ?   ?   ?   ?&#9; max is maximum acceptable
&#9;&#9; \___|___|___|___|___|___| _  _  input (range: 1 to 254)
&#9;&#9; On exit, the buffer is filled:
&#9;&#9; __________________________ _ _  len is actual length of
&#9;&#9; |max|len| T   E   X   T   0Dh&#9; input, less the termina-
&#9;&#9; \___|___|___|___|___|___| _  _  ting CR (eg, 4).
&#9;&#9; Characters are  read from  the Standard  Input up  to a  CR
&#9;&#9; (ASCII  13)  or  up  to  the  value  of max-1.  If max-1 is
&#9;&#9; reached, the console bell rings (beeps) for each  character
&#9;&#9; until Enter (CR) is read.
&#9;&#9; The second  byte of  the buffer  is filled  with the actual
&#9;&#9; length of the&#9;input, less the  terminating CR.   The final
&#9;&#9; character in the buffer is always CR (which is not  counted
&#9;&#9; in the length byte).
&#9;&#9; The characters  in the  buffer (including  the len)  before
&#9;&#9; the call are used as a "template" and the DOS editing&#9;keys
&#9;&#9; are in effect:  [Esc]&#9;displays "\" and restarts the  edit,
&#9;&#9; [F3] displays&#9;to the&#9;end of&#9;the template,  [F5] displays
&#9;&#9; "@"  and  stores  the&#9;current  line  as the template, etc.
&#9;&#9; Most Extended ASCII keystrokes are ignored.
&#9;&#9; If  Ctrl-Break  is  detected,&#9;INT  23h is executed and the
&#9;&#9; buffer is left unchanged.
    Fn 0Bh: Check Input Status
    --------------------------
    Expects: AH  0Bh
    Returns: AL  0FFh if a character is available from the Standard Input
&#9;&#9; 0    if no character is available
    Description: Checks the status of the Standard Input.
&#9;&#9; If Ctrl-Break is detected, INT 23h is executed.
    Notes:&#9; Use before Fns  01h, 07h and  08h to avoid  having DOS wait
&#9;&#9; for a key.
&#9;&#9; This  is  a  simple,  non-destructive&#9;way  to  check&#9; for
&#9;&#9; Ctrl-Break  during  long  calculations  or other processing
&#9;&#9; that does not&#9;normally look for  input.  It  lets the user
&#9;&#9; abort from such a sequence.
    Fn 0Ch: Clear &amp; Input
    ---------------------
    Expects: AH  0Ch
&#9;     AL  DOS input function number (01h, 06h, 07h, 08h, or 0Ah)
    Returns: none
    Description: Clears the  Standard Input  type-ahead buffer&#9;then invokes
&#9;&#9; the DOS input&#9;function specified by  AL.  This  forces the
&#9;&#9; system to wait for a character to be typed.
&#9;&#9; These values are allowed for AL:
&#9;&#9;    01h Keyboard Input
&#9;&#9;    06h Console I/O
&#9;&#9;    07h No Echo Unfiltered Input
&#9;&#9;    08h No Echo Filtered Input
&#9;&#9;    0Ah Buffered Input
    In addition to these functions, it&#9;is also possible to read a  selected
    amount  of&#9;characters  from  the  keyboard,  using  DOS's&#9;File  Handle
    functions, as the Keyboard, aka Standard Input, has a pre-set handle  of
    0000h:
    Fn 3Fh: Read from keyboard via Handle
    -------------------------------------
    Expects: AH  3Fh
&#9;     BX  0000h - Handle for Standard Input (Keyboard)
&#9;     DS:DX Address of buffer to receive data
&#9;     CX  Number of bytes to read
    Returns: AX  Error code if CF is set to CY
&#9;     AX  Number of bytes actually read
    Description: CX bytes of  data are read from  the keyboard. The data  is
&#9;&#9; placed into the caller's buffer pointed to by DS:DX.
    Notes:&#9; It  is  handy&#9;to  use  this  function  for reading default
&#9;&#9; handles such as  the Standard I/O  handles, instead of  the
&#9;&#9; buffered input or character-by-character input functions.
&#9;&#9; When you read from a  device, AX returns the length  of the
&#9;&#9; line up to and including the termination CR (ASCII 13h).
    3. BIOS Interfacing
    ___________________
    Pro:
&#9;- You get to know all the statusses and such
&#9;- It's a tad bit faster than DOS
&#9;- You can only read the keyboard
&#9;- It's easier than the really hardcore low level, and the keys
&#9;  are translated
    Contra:
&#9;- It is still to slow for games or demos
&#9;- You don't have bulk access, like strings
    The BIOS has 3 different ways of reading (parts of) the keyboard:
&#9;- functions
&#9;- keyboard flags
&#9;- keyboard buffer
    This part describes all of them.
    3.1. Functions
    ______________
    These functions can be accessed through int 16h.
    Fn 00h: Read (wait for) next keystroke
    --------------------------------------
    Expects: AH  0
    Returns: AL  ASCII&#9;character (if  AL=0, AH  is an Extended  ASCII&#9;key-
&#9;&#9; stroke)
&#9;     AH  Scan Code or Extended ASCII keystroke
    Fn 01h: Check if a keystroke is ready (and preview it if so)
    ------------------------------------------------------------
    Expects: AH  1
    Returns: ZF  ZR or 1 if no key is ready
&#9;     ZF  NZ or 0 if a key is ready.
&#9;     AX  is  set  as  for  Fn  00h  (but  the keystroke has not been
&#9;&#9; removed from the queue).
    Fn 02h: Read the shift-key status
    ---------------------------------
    Expects: AH  2
    Returns: AL  shift key and 'lock' status as in 83-keyboard flags
    Description: Determine which shift keys are currently being pressed  and
&#9;&#9; whether the keyboard is in NumLock state, etc.
    Fn 03h Set keyboard typeamatic rate and delay. (11/15/85 BIOS)
    --------------------------------------------------------------
    Expects: AH  3
&#9;     AL  05h (eg, AX = 0305h)
&#9;     BL  Typeamatic Rate
&#9;&#9; 0: 30 keys/sec  10: 10
&#9;&#9; 1: 26.7&#9; 13: 9
&#9;&#9; 2: 24&#9;&#9; 16: 7.5
&#9;&#9; 4: 20&#9;&#9; 20: 5
&#9;&#9; 8: 15&#9;&#9; 31: 2
&#9;     BH  Delay: 0=250ms 1=500ms 2=750ms 3=1 second)
    Returns: none
    Description: when a key is pressed, the keyboard will wait during Delay
&#9;&#9; before it starts repeating at Typematic Rate.
    Fn 05h Place a keystroke into the keyboard buffer. (11/15/85 BIOS)
    ------------------------------------------------------------------
    Expects: AH  5
&#9;     CL  ASCII character.
&#9;     CH  Scan Code  byte (or 0 if you don't care)
    Returns: AL  Status: 0=success; 1=buffer full
    Fn 10h Read (wait for) a keystroke; 101-keyboard only (11/15/85 BIOS)
    ---------------------------------------------------------------------
    Expects: AH  10h
    Returns: AL  ASCII&#9;character  (if&#9;AL=0,  AH is an  Extended ASCII key-
&#9;&#9; stroke)
&#9;     AH  Scan Code or Extended ASCII keystroke
    Fn 11h Preview keystroke; same as 01; 101-keyboard only (11/15/85 BIOS)
    -----------------------------------------------------------------------
    Expects: AH  11h
    Returns: ZF  ZR or 1 if no key is ready
&#9;     ZF  NZ or 0 if a key is ready.
&#9;     AX  set as for Fn 10 but keystroke is still in the buffer.
    12h Read shift-key status; same as 02; 101-keyboard only (11/15/85 BIOS)
    ------------------------------------------------------------------------
    Expects: AH  12H
    Returns: AL  shift key and 'lock' status as in 101-keyboard flags
    3.2. Keyboard Flags
    ___________________
    The keyboard flags are found in the BIOS Data Area: segment 40h.
    17h: 83-keyboard flags&#9;0=Off, 1=On
    ---------------------------------------
    bit 0: Right shift
&#9;1: Left shift
&#9;2: Ctrl, either side
&#9;3: Alt, either side
&#9;4: Scroll Lock
&#9;5: Num Lock
&#9;6: Caps Lock
&#9;7: Insert state
    Do NOT just change one of these and then hope the keyboard follows.  The
    LEDs will definitely get out of sync.
    18h: 101-keyboard flags&#9;0=Off, 1=On
    ---------------------------------------
    bit 0_&#9;&#9;   : Left ctrl
&#9;1|_At keyb. only   : Left Alt
&#9;2/&#9;&#9;   : Sys Req
&#9;3: Pause state
&#9;4: Scroll Lock&#9;   _
&#9;5: Num Lock&#9;   |_Being pressed
&#9;6: Caps Lock&#9;   |
&#9;7: Insert&#9;   /
    Do NOT just change one of these and then hope the keyboard follows.  The
    LEDs will definitely get out of sync.
    19h: Pseudokey value
    --------------------
    This is the  accumulating value of&#9;the key being  made with Alt+numeric
    keypad.  Normally 0
    71h: Ctrl-break flag&#9;0=Off, 1=On
    ---------------------------------------
    bit 7: Ctrl-Break was pressed. Never gets reset, unless you do.
    96h: AT only - keyboard ?&#9;0=Off, 1=On
    ---------------------------------------
    bit 4: 101/102 keyboard is attached
    97h: AT only - lock LEDs&#9;0=Off, 1=On
    ---------------------------------------
    bit 0: ScrollLock _
&#9;1: NumLock    |_ keyboard LED is turned on
&#9;2: CapsLock   /
    Do NOT just change one of these and then hope the keyboard&#9;follows.
    The LEDs will definitely get out of sync.
    3.3. Keyboard Buffer
    ____________________
    The keyboard  buffer is  a circular  data area.  This means  that when a
    pointer in the  buffer gets one  larger than the  buffer, it is  wrapped
    around to the beginning.
    The keyboard buffer is fed&#9;by int 9 and function  5 of int 16h.   It is
    found at the BIOS data segment, 40h. It is pointed to by 4 variables  in
    the BDA:  The  head (1ah), the tail  (1ch), the Beginning (80h)  and the
    End (82h). They are all words, pointing at locations in the BDA.
    The latter&#9;two are  only available  on ATs  and PSs.  They are  used to
    enlarge the keyboard buffer  by mapping it to  another spot in the&#9;BIOS
    data area.&#9;Normally, that spot is 32 bytes long starting from 1eh.
    The head is  the pointer to  the next word.  The tail is  the pointer to
    the next available word.  Each code is two bytes, the scan code and  the
    ASCII value.
    The buffer is empty if  the Head = the Tail  and it is full if  the Tail
    is two smaller than the Head, both counted circularly.  This means&#9;that
    the storage space equals (length buffer/2)-1.
    4. Low-Level Interfacing
    ________________________
    Pro:
&#9;- Fast
&#9;- Complete control
    Contra:
&#9;- Hard to code
&#9;- Totally NO functions at all. It's Handyman work here...
    The interfacing is split in two items:
&#9;- Just changing something, such as the LED's
&#9;- Reading out codes: int 9
    4.1. Interfacing And Configuring
    ________________________________
    The computer and  the AT or  MF II interface  through I/O ports  60h and
    64h, controlled  by a  programmable Intel  8042 (old  ATs), 8741 or 8742
    (newer, allow two  input devices (like  the PS/2 mouse))  microprocessor
    or compatible,  which allows  typematic rate  programming, LEDs lighting
    and some other stuff. It also  has a +-20 byte output buffer  for smooth
    operation and long scancodes.
    The  old  XT  keyboard  has  a  8048,  which  is  in essence just a very
    primitive one-way serial interface, so all used is port 61h, to  disable
    and reenable the keyboard on every scancode.
    Port 60h: Input &amp; output
    ------------------------
    Read: Scancodes and keyboarddata
    --------------------------------
    This port gives the following output codes:
&#9;00h: Keyboard error, too many keys are being pressed at once
&#9;aah: Basic Assurance Test (BAT) end
&#9;abh 41h: The result of requesting keyboard ID on a MF II keyboard
&#9;eeh: The result of the echo command
&#9;fah: ACK(noledge). Sent by every command, except eeh and feh
&#9;fch: BAT failed
&#9;feh: Resend your data please
&#9;ffh: Keyboard error
    All the rest are make (press) and break (release) codes of the keys.
    Write: Command data
    -------------------
    This is the  place where command  data has to  be sent.   If the command
    consists of two bytes, you must  wait until the outputbuffer is sent  to
    the keyboard.   Check on  it via  bit 1  of port  64h. When  you send  a
    command, the outputbuffer is cleared,  so pending results may not  come.
    During transmission of a two-byte command, the keyboard stops  scanning.
    When you  send something  out of  range or&#9;so, the  keyboard will react
    with feh  (resend).   All commands,  except echo  (eeh) and resend (feh)
    result in ACK (fah) to be sent.
    Commands:
    edh: Set keyboard LEDs
&#9; Send a second byte with:
&#9;     bit 0 = Scroll Lock&#9;0=Off 1=On
&#9;&#9; 1 = Num Lock
&#9;&#9; 2 = Caps Lock
&#9;      rest = 0
&#9; Do make an effort to keep the BIOS keyboard flags in sync.
    eeh: Great fun. Send it, and get 0eeh right back! :-]
&#9; (Diagnostics)
    f0h: Select scancode set.
&#9;     0: return current set number: 1:'C', 2:'A', 3:'?'
&#9;     1: set scancode set no 1
&#9;     2: set scancode set no 2 -&gt; standard
&#9;     3: set scancode set no 3
    f2h: Identify keyboard
&#9;     XT: nothing (that is, time-out error :-) (see port 64h)
&#9;     AT: ACK
&#9;     MF II: ACK abh 41h
    f3h: Typematic rate programming
&#9; Send a second byte with:
&#9;     bit 0 -&gt; 4: rate. Timings:
&#9;     0: 30 keys/sec   10: 10
&#9;     1: 26.7&#9;      13: 9
&#9;     2: 24&#9;      16: 7.5
&#9;     4: 20&#9;      20: 5
&#9;     8: 15&#9;      31: 2
&#9;     bit 5 &amp; 6: pause before repeat:
&#9;     0: 250 ms
&#9;     1: 500
&#9;     2: 750
&#9;     4: 1000
&#9;     bit 7: Always 0
    The next  three are  doubtfull, since  one of  my sources say they don't
    exist and another says they do. I leave it up to you :)
    f4h: Enable keyboard. It clears its buffer and starts scanning.
    f5h: Reset keyboard, disable scanning
    f6h: Reset keyboard, enable scanning
    feh: Resend last transmission. I really don't know what it does, since
&#9; it sends something incomprehesible.
    ffh: Internal diagnostics: Sends aah if successfull.  Warning! The
&#9; keyboard reacts with ACK and then you have to set the data and
&#9; clock pins high, DURING AT LEAST 500 SECONDS!. Do this via the
&#9; outputport (see 64h). After that, the BAT (Basic Assurance Test)
&#9; starts. This sends aah on success and fch on failure.
    Example: Set the keyboard LEDs
    start:
&#9;  in  al, 64h&#9;&#9;&#9;&#9;&#9; \It would be good
&#9;  and al, 02h&#9;;Test if command buffer is empty |to put this in a
&#9;  jnz start&#9;&#9;&#9;&#9;&#9; /macro...
&#9;  mov al, edh
&#9;  out 60h, al&#9;;Write outputport
    wait:
&#9;  in  al, 64h
&#9;  and al, 02h&#9;;Test if command came through
&#9;  jnz wait
&#9;  mov al, 0111b
&#9;  out 60h, al&#9;;Set all LED's to ON.
    Port 61h
    --------
    This  port&#9;is  used  to  acknoledge  the  receival  of  a&#9;scancode, by
    disabling the keyboard  and immediately reenabling&#9;it. This also  means
    that  you  can  read  a  scancode  as  many times as you like, until you
    acknoledge the receival.
    bit 0 -&gt; 5: Nothing to do with keyboard, but with the Programmable
&#9;&#9;Peripheral Interface (PPI) -&gt; save them!
    bit 6: Hold keyboard clock low -&gt; Keyboard can't send any data.
    bit 7: 0=Enable keyboard; 1=Disable keyboard
    Example:
&#9;  in  al, 61h
&#9;  mov ah, al&#9;;Save keyboard status
&#9;  or  al, 80h&#9;;Disable
&#9;  out 61h, al
&#9;  mov al, ah&#9;;Enable (If it was disabled at first, you wouldn't
&#9;  out 61h, al&#9;; be doing this anyway :-)
    Port 64h: Interface: data and control
    -------------------------------------
    Read: Statusport
    ----------------
&#9;bit 0: 1: Keyboard data is in buffer
&#9;       0: Output buffer empty -&gt; use it to check for results
&#9;    1: 1: User data is in buffer
&#9;       0: Command buffer is empty -&gt; time to send a command
&#9;    2: 1: Selftest successful
&#9;       0: Reset (?)
&#9;    3: 1: 64h was last accessed port
&#9;       0: 60h was last accessed port
&#9;    4: 1: Keyboard enabled
&#9;       0: Keyboard locked
&#9;    5: PS/2: Mouse interface
&#9;    6: 1: Time-out error occurred: Keyboard or PS/2 mouse didn't
&#9;&#9;  react. Use the Resend command to retry fetching the data
&#9;&#9;  byte. This could happen when trying to get a XT keyboard
&#9;&#9;  to do something :).
&#9;    7: 1: Last transmission had a parity error
    Write: Control register
    -----------------------
    This is the control room  of the keyboard interface. If  additional data
    is required,  send it  to port  60h after  writing the  command to&#9;64h.
    Also, check 61h bit 2 before sending anything.
    Commands:
    aah: Keyboard self test. Sends 55h if successfull.
    abh: Test interface. Sends:
&#9;     00h: No error
&#9;     01h: Clock low
&#9;     02h: Clock high
&#9;     03h: Data low
&#9;     04h: Data high
&#9;     ffh: Total Error
    adh: Deactivate keyboard
    aeh: Activate keyboard
    c0h: Read inputport. This is some highly specialized stuff and I wonder
&#9; why I am typing this. Ok. The inputport is that what the keyboard
&#9; is sending and some more. Layout:
&#9;     bit 0: Keyboard data in pin
&#9;&#9; 1: PS/2 mouse in pin
&#9;&#9; 2-&gt;5: reserved
&#9;&#9; 6: Wether you have a color or mono screen
&#9;&#9; 7: 1: Keyboard not locked
&#9;&#9;    0: Keyboard locked
&#9; When you issue this command, the inputport is put on the
&#9; outputbuffer, so you have the great priviledge of reading it at
&#9; port 60h.
    c1h: Puts the low nibble of the input port over bits 4-7 of the
&#9; statusport, so you can read them out continuously. This lasts
&#9; until bit 2 of the statusport gets set, meaning you are sending
&#9; data to the keyboard.
    c2h: Ditto, but it puts the high nibble over bits 0-3 of the
&#9; statusport. Lifespan is the same.
    d0h: Puts the outputport on the buffer. Layout:
&#9;     bit 0: 1: Reset processor
&#9;&#9; 1: 1: A20 gate enable
&#9;&#9; 2: PS/2 mouse data out
&#9;&#9; 3: PS/2 mouse clock signal
&#9;&#9; 4: 1: Output buffer full
&#9;&#9; 5: 1: Output buffer PS/2 mouse full
&#9;&#9; 6: Keyboard clock signal
&#9;&#9; 7: Keyboard data out
&#9; Bit 0 and 1 are quite important for high memory and
&#9; 286-extended-memory access.
    d1h: Write the following data byte to the outputport
    d2h: Write the following data byte to the keyboardbuffer. This is VERY
&#9; handy for TSRs that need to read codes that start with e0h. This
&#9; way, they don't have to pass through the e0h, unless they know for
&#9; sure it isn't their code, which results in correct functioning
&#9; shift keys etc. At least, if it does what I think it
&#9; does... [UNTESTED]
    d3h: Ditto, for PS/2 mouse.
    d4h: Write byte to PS/2 mouse.
    e0h: Reads the keyboards testinputs, T0 and T1. T0 goes to bit 0 and T1
&#9; to bit 1 of the byte that is put on the outputbuffer.
    fxh: I think it sends x to the low nibble of the output port. It does
&#9; reset my computer when I send feh, but that doesn't mean anything
&#9; :-). The official explanation says that it keeps the corresponding
&#9; bits in the output port low for 6ms...
    Example: Send something to the outputport
    start:
&#9;  in  al, 64h&#9;&#9;&#9;&#9;&#9;\It would be good
&#9;  and al, 02h&#9;;Test if command buffer is empty|to put this in a
&#9;  jnz start&#9;&#9;&#9;&#9;&#9;/macro...
&#9;  mov al, d1h
&#9;  out 64h, al&#9;;Write outputport
    wait:
&#9;  in  al, 64h
&#9;  and al, 02h&#9;;Test if command came through
&#9;  jnz wait
&#9;  mov al, 01h
&#9;  out 60h, al
    4.2. Lay-Out
    ____________
    The keyboard first&#9;consisted of 83  keys, which is now known as  the XT
    keyboard.&#9;Then  came  along  the&#9;AT-keyboard,  which  has  84 keys, a
    slightly different layout and an extra SysReq key. The next keyboard  is
    the MF II keyboard.  This one has  101 or 102 keys, and this is the  one
    this section will be babbling about.
    The keycaps  change, but&#9;the  most popular  settings are  QWERTY  and
    AZERTY.  Also popular is the Dvorak lay-out, made&#9; by  what's-his-name
    Dvorak, who made  the lay-out so  that both hands  did not have  to move
    that much, resulting in fast (up  to double) typing speed.&#9;This  is it,
    should  you be  interested&#9;(slight  modifications&#9;by  me,  because  it
    actually requires a 12x4 keyboard):
&#9;    101 - key&#9;&#9;&#9;      102 - key
    ~ ! @ # $ % ^ &amp; * ( ) [ +&#9;      &uuml; ! @ # $ % ^ &amp; * ( ) [ +
    ` 1 2 3 4 5 6 7 8 9 0 ] =&#9;      &yacute; 1 2 3 4 5 6 7 8 9 0 ] =
      " , . P Y F G C R L ? { | &#9;" , . P Y F G C R L ? {
      ' , . p y f g c r l / } \ &#9;' , . p y f g c r l / }
      A O E U I D H T N S _ &lt;&#9;&#9;A O E U I D H T N S _ ~
      a o e u i d h t n s - &gt;&#9;&#9;a o e u i d h t n s - `
      : Q J K X B M W V Z&#9;      &gt; : Q J K X B M W V Z
      ; q j k x b m w v z&#9;      &lt; ; q j k x b m w v z
    The key lay-out is as follows: (The numbers are internal to the
    keyboard)
    US-English Keyboard: 101 keys
    -----------------------------
    _____________________________________________________
    |10||12|13|14|15||16|17|18|19||20|21|22|23||24|25|26| &lt;__ Add 100 to the
    \__/\__|__|__|__/\__|__|__|__/\__|__|__|__/\__|__|__/     keycodes on
&#9;&#9;&#9;&#9;&#9;&#9;&#9;      this line
    ____________________________________________________________________
    |1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13| 15||75|80|85||90|95|100|105|
    |_|__|__|__|__|__|__|__|__|__|__|__|__|___/|__|__|__/|__|__|___|___/
    |16|17|18|19|20|21|22|23|24|25|26|27|28|29||76|81|86||91|96|101|   |
    |__|__|__|__|__|__|__|__|__|__|__|__|__|__/\__|__|__/|__|__|___/   |
    |30 |31|32|33|34|35|36|37|38|39|40|41| 43 | &#9; |92|97|102|106|
    |___|__|__|__|__|__|__|__|__|__|__|__|____/   ____&#9; |__|__|___|___/
    | 44  |46|47|48|49|50|51|52|53|54|55|  57 |   |83|&#9; |93|98|103|   |
    |_____|__|__|__|__|__|__|__|__|__|__|_____/___|__|___|__|__|___/   |
    |58 | |60 | &#9; 61&#9;    | 62| | 64||79|84|89|| 99  |104|108|
    \___/ \___|_____________________|___/ \___/\__|__|__/\_____|___|___/
&#9;&#9;&#9;&#9;  |
    This has the extra 29 key, or \
    Other Countries: 102 keys
    -------------------------
    _____________________________________________________
    |10||12|13|14|15||16|17|18|19||20|21|22|23||24|25|26| &lt;__ Add 100 to the
    \__/\__|__|__|__/\__|__|__|__/\__|__|__|__/\__|__|__/     keycodes on
&#9;&#9;&#9;&#9;&#9;&#9;&#9;      this line
    ____________________________________________________________________
    |1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13| 15||75|80|85||90|95|100|105|
    |_|__|__|__|__|__|__|__|__|__|__|__|__|___/|__|__|__/|__|__|___|___/
    |16|17|18|19|20|21|22|23|24|25|26|27|28|43||76|81|86||91|96|101|   |
    |__|__|__|__|__|__|__|__|__|__|__|__|__|_ |\__|__|__/|__|__|___/   |
    |30 |31|32|33|34|35|36|37|38|39|40|41|42| | &#9; |92|97|102|106|
    |___|__|__|__|__|__|__|__|__|__|__|__|__|_/   ____&#9; |__|__|___|___/
    |44|45|46|47|48|49|50|51|52|53|54|55|  57 |   |83|&#9; |93|98|103|   |
    |__|__|__|__|__|__|__|__|__|__|__|__|_____/___|__|___|__|__|___/   |
    |58 | |60 | &#9; 61&#9;    | 62| | 64||79|84|89|| 99  |104|108|
    \___/ \___|_____________________|___/ \___/\__|__|__/\_____|___|___/
    This  has  the  extra  42  and  45&#9;keys.  Their characters change from
    country to country.
    4.3. Scancodes
    ______________
    The AT-keyboard has 3 separate scancode settings:&#9; One as we know  it,
    (83 key-mapping, and added codes have an extra e0h added), one  (almost)
    sequential and one with ONE byte codes! Problem with the latter is&#9;that
    only  for  lshift,&#9;caps,  lctrl  and  lalt breakcodes are sent :-(. The
    keyboard starts up in  set 2, the set  can be changed via  port 64h (see
    above).
    In set 1 and  2, there are special&#9;codes, namely e0h and  e1h. They are
    used for keys that&#9;have  the same function.   An example:&#9;1dh  for the
    left control  key and  e0h 1dh  for the  right one.   This is  done  for
    lowlevel compatibility with XT programs.  Notice that the only time  e1h
    is used, is when it represents  a temporary control key, which also  has
    a e0h version.
    e0h  2ah  is  a  temporary&#9;shift  function, used by for example PrtScr,
    which is  in reality  shift-numkeypad-*, like  on the  XT keyboard.  See
    below for further information.
    The code will be sent as shown  further.  The codes listed are the&#9;make
    codes. They are sent when a  key is pressed. Upon release, the  keyboard
    sends a break  code. It is&#9;the make code,&#9;but ORed with  80h. The only
    exception to this are the codes e0h and e1h, which remain the same.   So
    for example  pressing and  releasing the  right ctrl  key would give e0h
    1dh and e0h 9dh. I only give the codes for set 2 because the rest  would
    be too much work  and stupid. If you  want them, look them&#9;up yourself.
    Modify any of the accompanying source codes or so...
    &oslash;  Only on US-English keyboards
    &oslash;&oslash; Only on other country versions
    Scancodes are in hex.
    Key  Scan  Key  Scan  Key  Scan  Key  Scan&#9;Key  Scan  Key&#9;Scan
    no.  code  no.  code  no.  code  no.  code&#9;no.  code  no.&#9;code
    _________________________________________________________________
    1&#9;|29   |19  |12&#9; |36  |23   |53  |33   |86  |e0 51|106 |4e
    2&#9;|02   |20  |13&#9; |37  |24   |54  |34   |89  |e0 4d|108 |e0 1c
    3&#9;|03   |21  |14&#9; |38  |25   |55  |35   |90  |45   |110 |01
    4&#9;|04   |22  |15&#9; |39  |26   |57  |36   |91  |47   |112 |3b
    5&#9;|05   |23  |16&#9; |40  |27   |58  |1d   |92  |4b   |113 |3c
    6&#9;|06   |24  |17&#9; |41  |28   |60  |38   |93  |4f   |114 |3d
    7&#9;|07   |25  |18&#9; |42&oslash;&oslash;|2b   |61  |39   |95  |e0 35|115 |3e
    8&#9;|08   |26  |19&#9; |43  |1c   |62  |e0 38|96  |48   |116 |3f
    9&#9;|09   |27  |1a&#9; |44  |2a   |64  |e0 1d|97  |4c   |117 |40
    10&#9;|0a   |28  |1b&#9; |45&oslash;&oslash;|56   |75  |e0 52|98  |50   |118 |41
    11&#9;|0b   |29&oslash; |2b&#9; |46  |2c   |76  |e0 53|99  |52   |119 |42
    12&#9;|0c   |30  |3a&#9; |47  |2d   |79  |e0 4b|100 |37   |120 |43
    13&#9;|0d   |31  |1e&#9; |48  |2e   |80  |e0 47|101 |49   |121 |44
    15&#9;|0e   |32  |1f&#9; |49  |2f   |81  |e0 4f|102 |4d   |122 |57
    16&#9;|0f   |33  |20&#9; |50  |30   |83  |e0 48|103 |51   |123 |58
    17&#9;|10   |34  |21&#9; |51  |31   |84  |e0 50|104 |53   |124 |(*)
    18&#9;|11   |35  |22&#9; |52  |32   |85  |e0 49|105 |4a   |125 |46
&#9;&#9;&#9;&#9;&#9;&#9;&#9;  |126 |(*)
    (*)
    Key 124, AKA PrtScr/SysRq, is both. When pressed normally, it will&#9;send
    (hex) e0 2a e0  37. This is in  fact a special shift-*,  or the original
    place of that code on the XT keyboard.
    Used in conjuction with:
    Normal: e0 2a e0 37
    Shift : e0 37
    Ctrl  : e0 37
    Alt   : e0 54
    Key 126: Pause/Break. On the  XT keyboard, this used to  be ctrl-NumLock
    and ctrl-ScrollLock. Now guess the&#9;codes...   Very special  is that the
    break codes are sent immediately after  the make codes. I think that  is
    because the codes have odd length.
    Normal: e1 1d 45   (e0 1d is already used by rightctrl)
    Ctrl  : e0 46      (46 is the code for ScrollLock...)
    4.4. Int 9
    __________
    When a key is pressed or released, or when the 8042 sends an ACK or  NAK
    the keyboard triggers  IRQ1, or int  9.  This  can be masked  by setting
    bit 1 on port 21h, the  interrupt controller.  Int 9 gets  the scancode,
    translates it and puts it in the keyboard buffer.
    BEWARE: When a scancode consists of more than 1 byte,  it should be read
    ------  one byte per call. (Took me quite long to find out...)
    Translating:
    -----------
    Int 9 will&#9;first call int&#9;15h, subfunction 4fh,  with the scancode  in
    al.   If  the  scancode  is  legitimate,  the  carry flag is set, and al
    contains the  scancode.   If not,  the carry  flag is  reset, and  int 9
    stops.   (The  carries  are  picked  so  that  if  int 9 thinks the BIOS
    supports the call and it doesn't, the carry is set by the BIOS, and  the
    scancode can always be used). This allows the keyboard to be  redefined,
    by&#9;taking&#9;over  the  function  and  replacing scancodes.
    If you want to take over int  9, you must remember to let the  interrupt
    controller&#9;know when  you are  finished, by  writing 20h  to port&#9;20h,
    since this is a  hardware interrupt.  You  should also disable and&#9;then
    reenable the keyboard (see port 61h), so the keyboard knows you got  the
    code. The codes come in one byte per IRQ, so save e0hs.
    The key will be translated by int 9, with the following special cases:
    00h:
&#9;User is pressing too many keys at once: beep or something
    aah, bah 41h, eeh, fah, feh:
&#9;Ignore it. Someone is playing with port 60h
    fch, ffh:
&#9;Ditto, but now you know the keyboard is screwed up :)
    e0h 2ah:
&#9;Well. If you let the keyboard decide what the NumLock state is
&#9;(nothing to do with the LED), use it to see how the code must be
&#9;translated (e0h 2ah: NumLock is on). Else, ignore. (Most Smart)
    Ctrl-NumLock or Pause:
&#9;Place system in a tight wait loop until next key pressed. It  would
&#9;be friendly to allow hardware IRQ's... (clock, comms etc) (I think)
    Ctrl-Break:
&#9;Clear keyboard buffer  (=Equal Head and  Tail), place word  0000h in
&#9;buffer, invoke int 23h, and set flag at 0040h:0071h (bit 7=1).
    Shift-PrtScr:
&#9;Invoke int 5
    Ctrl-PrtScr:
&#9;redirect CON to PRN. (Teletype mode)
&#9;Never used it, perhaps never will. Doesn't work on my keyboard
&#9;driver... (DOS) Don't know how to stop it.  Perhaps rehitting
&#9;Ctrl-PrtScr... This is from hearsay.
    SysRq:
&#9;Invoke int 15 subfunction 85h. al-&gt;0 when pressed, 1 when released.
    Ctrl-Alt-Del:
&#9;Reboot. Here's a sample of how to reboot:
&#9;mov ah,0Dh&#9;&#9;     ; Disk Reset
&#9;int 21h &#9;&#9;     ; causes SmartDrv 4.x to write cache
&#9;mov ax, 40h&#9;&#9;     ; set up segment addressing
&#9;mov ds,ax
&#9;or  byte ptr ds:[17h],0Ch    ; equivalent of pressing CTRL+ALT
&#9;mov ax,4F53h&#9;&#9;     ; Issue a "DEL" (53h = DEL scan code)
&#9;int 15h &#9;&#9;     ; EMM386 sees this &amp; shuts down
&#9;mov word ptr ds:[72h],1234h  ; Set REBOOT flag to Warm-Boot (0=cold)
&#9;db 0EAh,0h,0h,0FFh,0FFh      ; JMP FFFF:0000
&#9;Of course, the int 15h call should already have been done by the
&#9;handler. It is also used by other caches to flush.
    Shift-numkeypad:
&#9;Temporarily reverse the NumLock state, e.g. 8 becomes arrow up and
&#9;vice versa.
    Alt+numkeypad:
&#9;Make the pseudokey in BDA byte 19h until the alt is released, then
&#9;put it in the keyboard buffer. How? Well, everytime an extra number
&#9;comes in, multiply BDA:19h with 10 and add the new number.
    Alt release:
&#9;See above. Just making sure it is implemented ;-)
    Ctrl+a-&gt;z:
&#9;Send bytes 1 through 27
    Foreign keyboards:
&#9;Some keys are accents, to be placed on the next key.
    Right alt:
&#9;Some keys have three keys on it. To access them, the right alt is
&#9;pressed. So remember to send the right ASCII code...
    NumLock:
&#9;Switch numkeypad on/off and light/switch off LED
    CapsLock:
&#9;Translate normal letters to caps or vice versa and light/switch off
&#9;LED. A nice touch would be to have a distinction between CapsLock
&#9;and Ctrl-CapsLock. The former would shift alfabetic
&#9;keys only and the latter all keys...
    ScrollLock:
&#9;Light/sw. off LED
    Int  9  also  has  to  adjust  the&#9;BDA  flags  and  keyboard buffer. In
    addition, the driver should warn when the keyboard buffer is full.
    5. Tech Stuff
    _____________
    Interface:
&#9;Bidirectional,&#9;serial&#9;synchronous.  The  keyboard communicates via
&#9;clock and data line with the system. The data comes in 11 bit
&#9;packets, namely start-data-parity-stop. Parity is uneven.
&#9;&#9;&#9; =1   8bit  1bit   =0
&#9;Also, see further.
    Data Format:
&#9;Data transfer to and from the keyboard in IBM-compatible format:
&#9;AT-, PS/2-mode: Idle state - "Data &amp; Clock" high.
&#9;PC mode:&#9;Idle state - "Data" low, "Clock" high.
    Data Output:
&#9;Open drain.
    Keyboard Sequence:
&#9;Alpha-N-key-rollover.
    Automatic repeat function:
&#9;All  keys  have  auto  repeat.&#9; Delay&#9;and  repeat  sequence can be
&#9;modified through the system, but  is fixed for PC-mode. (10Hz  after
&#9;500ms)
    Keyboard Self-diagnostic test:
&#9;After  "Power-On"  or  upon  request,  the  keyboard  carries  out a
&#9;self-diagnostic test. After positive  test, the keyboard sends&#9;AAh.
&#9;Any other is a failure.
    Pin assignment:
&#9;  ___&#9;&#9;&#9; 1 Clock
&#9; /524\&#9;&#9;&#9; 2 Data
&#9;|3   1|__&#9;&#9; 3 Not used
&#9; \_&iuml;_/&#9;|chassis gnd&#9; 4 Gnd
&#9;&#9;-&#9;&#9; 5 +5V (This is the place to tap from :-)
&#9;PS/2 adaptor:&#9;&#9; 1 Data
&#9;  _ _&#9;&#9;&#9; 2 Not used
&#9; /5U6\&#9;&#9;&#9; 3 Gnd
&#9;|3   4|__&#9;&#9; 4 +5V
&#9; \1_2/&#9;|chassis gnd&#9; 5 Clock
&#9;&#9;-&#9;&#9; 6 Not used
    The PC-XT keyboard communication protocol
    -----------------------------------------
    Below is a drawing of the timing of the data, send to the PC. The  upper
    line shows&#9;the clock  line, the  lower the  data line.  The text  above
    indicates the position of the start, data and stop bits (clocked on  the
    negative edge of the clock line).
    Start    1&#9;   2&#9; 3     4     5&#9;   6&#9; 7     8     Stop
       |     |&#9;   |&#9; |     |     |&#9;   |&#9; |     |     |
    ____  ____&#9;____  ____  ____  ____&#9;____  ____  ____  ____&#9;____
    clk\__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/
    ________________________________________________________&#9;  __
    dta     \_____|_____|_____|_____|_____|_____|_____|____|______/
    The communication abides to the following rules:
&#9;- On power up or reset, the PC pulls the clock line (normally  high)
&#9;  low for at  least 20 ms.  When it is&#9;released (goes high  again),
&#9;  the keyboard should send the code  0AAh to the PC to indicate  its
&#9;  existance.
&#9;- The data is clocked in  on the negative edge of the  clock signal.
&#9;  The  clock  line  must  normally  be&#9;high,  the  data line can be
&#9;  anything between transmissions. The  clock line is delayed  two PC
&#9;  clock cycles&#9;in the&#9;PC, so&#9;data changes  and the negative clock
&#9;  edge may take  place at the  same time. It  is safer, however,  to
&#9;  build in a bigger delay.
&#9;- A transmission starts with  a start bit (high). Then&#9;follow eight
&#9;  data bits, of witch bit 7 (MSB) indicates the release of the&#9;key.
&#9;  After that  normally follows&#9;a stop&#9;bit (low),  but that  may be
&#9;  left out. In fact, due  to the shift register hardware  inside the
&#9;  PC, any number  of stop bits&#9;could be send,&#9;as long as  they are
&#9;  low.&#9; Not 100%  hardware compatibles,  however, may&#9;get confused
&#9;  then.
&#9;- After a transmission, the PC&#9;pulls the data line low until  it is
&#9;  ready processing the data.  The keyboard should wait&#9;with sending
&#9;  any more data until the PC releases the data line again.
    A. Acknowledgments
    __________________
    This  text&#9;was  made  by  Wout  Mertens,  with the help of Tech Help of
    Flambeaux software, the tech spex of Cherry and some texts I found.
    Information on the PC-XT keyboard communication protocol and the
    kbfunc.c file by Gertjan Klein (Floating somewhere in cyberspace).
    Cherry is the registered trademark of Cherry Microschalter Gmbh etc.
    IBM is the registered trademark of the IBM corporation
    Mertens is the registered trademark of the Mertens Family ;-)
    Improved copyright notice, thanks &amp; greetings to:
&#9;Emil Gilliam (Floating in cyberspace as well)
&#9;Kip Cooley at the Diamond Bar BBS (909) 923-1031 (1:218/101).
&#9;Ian Remmler at the DownTown BBS (210) 625-4479 (1:387/1001).
    B. How To Contact Me
    ____________________
    Please let me know&#9;if something is inaccurate or missing etc.  Also,  I
    would like&#9;some  feedback on  the quality&#9;and usability  of this text.
    (Keeps me&#9;writing...) If you think this text is very usefull, you  can
    always send me a nice postcard from where you live to thank me... I will
    then try to notify you when a new version arrives.
    I am usually  reachable through the  Fido 80XXX echo,  but you can&#9;also
    reach me at the following addresses:
&#9;Fido 2:292/805.1
&#9;SBC  14:1900/457
&#9;DGI  68:320/1.3
&#9;CDN  94:810/1104
&#9;CIN  112:913/101.4
&#9;SnailMail: Wout Mertens
&#9;&#9;   Jozef de Bomstr 62
&#9;&#9;   2018 Antwerp
&#9;&#9;   Belgium - Europe
    C. The Answer To Life, The Universe And All The Rest
    ____________________________________________________
    42.
    PS: Could anyone tell me the Question?
    (With thanks to Douglas Adams :-)
    D. History
    __________
    20 feb 94: release of v1.0
    5  apr 94: changed info on rebooting in int 9
&#9;       added info about XT protocol, by Gertjan Klein
&#9;       added C program to interface with keyboard, by Gertjan Klein
&#9;       removed a bug in the copyright: Emil Gilliam was not to be
&#9;       held liable :-):-):-)
&#9;       removed some general typing errors
    9  apr 94: removed bug in keyboard buffer info: Head and Tail do not
&#9;       point to a location relative to Beginning, but instead
&#9;       directly to the keyboardbuffer
    23 may 94: v1.1
 
________________________________________________________________
|File passed thru : [ E X T A S Y ]  |      +49-(0)30-341-2912 |
|____________________________________/       USR DUAL HST 16.8 |
| [x] Files passed CRC Test          |       ONLiNE  24  HOURS |
| [x] Files passed ViRUS Test        |       SYSOP : NIGHTHAWK |
|                                    | /\/\/\/\/\/\/\/\/\/\/\/ |
| DIZ IZ AN -$CiENCE FRONTiER$- TOOL | MORE THAN 5 GiGS OF IBM |
|     [ ADVANCED CHECKER GOLD ]      | PUBLiC DOMAiN, SHARE-   |
|   written 1993/94 by Alien / SF    | FREEWARE &amp; SEXGiFS !!!! |
\____________________________________|_________________________/
<hr>

<table border="0" cellpadding="3" cellspacing="0">
    <tr>
        <td width="148"><p align="right"><img src="../images/ingles.gif"
        width="73" height="40"><img src="../images/atras.jpg" width="44"
        height="45"></p>
        </td>
        <td><a href="../english/idoc_on.htm">Come back to on-line documentation</a></td>
    </tr>
    <tr>
        <td><p align="right"><img src="../images/espanol.gif" width="80"
        height="44"><img src="../images/atras.jpg" width="44" height="45"></p>
        </td>
        <td><a href="../spanish/doc_on.htm">Vuelve a Documentos on-line</a></td>
    </tr>
</table>
<p align="center"><a href="mailto:zeusv2@geocities.com"><img
src="../images/mail.gif" border="0" hspace="20" width="50" height="60"></a><a
href="mailto:zeusv2@geocities.com"><br>
zeusv2@geocities.com </a></p>

<p align="center"><!---------comienzo icono del nedstat------------> <a
href="http://es.nedstat.net/cgi-bin/viewstat?name=zeusv2"><img
src="http://es.nedstat.net/cgi-bin/nedstat.gif?name=zeusv2"
border="0" width="22" height="22"></a> <!---------fin icono del nedstat------------> </p>

<hr>
<p align="center"><b>Esta página está hospedada en </b><a
href="/"><b><img src="/pictures/gc_icon.gif" align="middle"
border="0"></b></a><b> &nbsp; Consigue tu </b><a href="/"><b&>Página Web Gratis</b></a><b><br>
</b></p></PRE></BODY>
</HTML>

<!-- text below generated by server. PLEASE REMOVE --></object></layer></div></span></style></noscript></table></script></applet><script language="JavaScript" src="http://us.i1.yimg.com/us.yimg.com/i/mc/mc.js"></script><script language="JavaScript" src="http://us.js2.yimg.com/us.js.yimg.com/lib/smb/js/hosting/cp/js_source/geov2_001.js"></script><script language="javascript">geovisit();</script><noscript><img src="http://visit.geocities.yahoo.com/visit.gif?us1215081628" alt="setstats" border="0" width="1" height="1"></noscript>
<IMG SRC="http://geo.yahoo.com/serv?s=76001067&t=1215081628&f=us-w86" ALT=1 WIDTH=1 HEIGHT=1>
